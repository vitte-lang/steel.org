
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Steel Wiki — Deterministic Configuration</title>
    <meta name="description" content="Wiki Steel: pipeline de configuration, fichiers clefs, analyses et commandes." />
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  </head>
  <body>
    <div class="bg-shapes" aria-hidden="true"></div>
    <header class="hero">
      <nav class="nav">
        <div class="brand">
          <span class="brand-dot"></span>
          <span class="brand-text" data-i18n="brand">Steel</span>
        </div>
        <div class="nav-links">
          <a href="#vision" data-i18n="nav_vision">Vision</a>
          <a href="#pipeline" data-i18n="nav_pipeline">pipeline</a>
          <a href="#analyse" data-i18n="nav_analyse">Analyse</a>
          <a href="#examples" data-i18n="nav_examples">Exemples</a>
          <a href="#code" data-i18n="nav_code">Code</a>
          <a href="#deep-dive" data-i18n="nav_deep_dive">Deep diving</a>
          <a href="#contrats" data-i18n="nav_contrats">Contrats</a>
          <a href="#cli" data-i18n="nav_cli">CLI</a>
          <a href="#commandes" data-i18n="nav_commandes">Commandes</a>
        </div>
        <a class="cta" href="#quickstart">Demarrer</a>
</nav>

      <div class="hero-content">
        <div>
          <p class="kicker" data-i18n="hero_kicker">Configuration declarative Steel</p>
          <h1 data-i18n="hero_title">Same pipeline for all: steelconf configures, steel produces the binary.</h1>
          <p class="lead" data-i18n="hero_lead">
            Ce wiki explique le flux, les contrats et la logique d'analyse qui rendent le build deterministe.
          </p>
          <div class="hero-actions">
            <a class="primary" href="#quickstart" data-i18n="hero_primary">See the route</a>
            <a class="ghost" href="#contrats" data-i18n="hero_ghost">Read key files</a>
          </div>
        </div>
        <div class="hero-card">
          <p class="hero-card-title" data-i18n="hero_card_title">Cycle steel</p>
          <ol>
            <li data-i18n="hero_step_1">Loading the  <code>steelconf</code></li>
            <li data-i18n="hero_step_2">Validation of constraints</li>
            <li data-i18n="hero_step_3">Resolution (profiles, overrides)</li>
            <li data-i18n="hero_step_5">build</li>
          </ol>
          <div class="chip-row">
            <span class="chip" data-i18n="chip_deterministe">Deterministe</span>
            <span class="chip" data-i18n="chip_outillable">Outillable</span>
            <span class="chip" data-i18n="chip_multi_os">Multi-OS</span>
          </div>
        </div>
      </div>
    </header>

    <main>
      <section id="vision" class="section">
        <div class="section-title">
          <p class="kicker">Vision</p>
          <h2>A unique config, a canonical output.</h2>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Why Steel</h3>
            <p>
                            Steel separates configuration from execution. The objective is to make
              the portable, observable and reproducible build, whatever the language
              or the machine.
            
            </p>
            <ul>
              <li>Declarative, explicit and stable configuration</li>
              <li>Canonical artifact for audit, CI and debug</li>
              <li>Native introspection (print/graph)</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="pipeline" class="section">
        <div class="section-title">
          <p class="kicker">pipeline</p>
          <h2>Freeze then Build.</h2>
        </div>
        <div class="timeline">
          <div class="step">
            <span class="step-index">01</span>
            <div>
              <h3>Configuration</h3>
              <p>Loading the workspace, profiles, targets and toolchains.</p>
            </div>
          </div>
          <div class="step">
            <span class="step-index">02</span>
            <div>
              <h3>Validation</h3>
              <p>Constraints, compatibility, references and global coherence.</p>
            </div>
          </div>
          <div class="step">
            <span class="step-index">03</span>
            <div>
              <h3>Resolution</h3>
              <p>Inheritance, overrides, variables and toolchain fingerprints.</p>
            </div>
          </div>
          <div class="step">
            <span class="step-index">04</span>
            <div>
              <h3>Emission</h3>
              <p>Generation of <code>steel.log</code>, stable and tooling-friendly format.</p>
            </div>
          </div>
          <div class="step">
            <span class="step-index">05</span>
            <div>
              <h3>build</h3>
              <p>Steel builds the DAG and executes the compilation steps.</p>
            </div>
          </div>
        </div>
      </section>

      <section id="quickstart" class="section">
        <div class="section-title">
          <p class="kicker">Quickstart</p>
          <h2>Install Steel and get started quickly.</h2>
        </div>
        <p class="muted-line">
                    Downloadable as executable from
          
          <a href="https://github.com/vitte-lang/steel.org/releases">github.com/vitte-lang/steel.org/releases</a>
        </p>
        <div class="grid three">
          <div class="panel">
            <h3>1. Install Steel</h3>
            <p>
                            Download the official release from
              
              <a href="https://github.com/vitte-lang/steel.org/releases">github.com/vitte-lang/steel.org/releases</a>
                            and place the binary in your  <code>PATH</code>.
            </p>
          </div>
          <div class="panel">
            <h3>2. Check the installation</h3>
            <p>
              Run <code>steel --version</code>  to confirm that the tool is accessible.
            
            </p>
          </div>
          <div class="panel">
            <h3>3. First build</h3>
            <p>
                            Create a  <code>steelconf</code>, then execute  <code>steel</code>
                            to generate  <code>steel.log</code>.
            </p>
          </div>
        </div>
        <div class="grid two">
          <div class="panel terminal">
            <h3>Telecharger</h3>
            <pre><code class="language-text">$ open https://github.com/vitte-lang/steel.org/releases
$ curl -L -o steel.tar.gz &lt;URL_DU_RELEASE&gt;
$ tar -xzf steel.tar.gz</code></pre>
          </div>
          <div class="panel terminal">
            <h3>Installer</h3>
            <pre><code class="language-text">$ chmod +x steel
$ sudo mv steel /usr/local/bin/steel
$ steel --version</code></pre>
          </div>
        </div>
        <div class="grid two">
          <div class="panel terminal">
            <h3>Build a project</h3>
            <pre><code class="language-text">$ mkdir demo-steel
$ cd demo-steel
$ ls
src
steelconf</code></pre>
          </div>
          <div class="panel terminal">
            <h3>steelconf example</h3>
            <pre><code class="language-text">$ cat &gt; steelconf &lt;&lt;'EOF'
!muf 4

[workspace]
  .set name "demo"
  .set root "."
  .set target_dir "target"
  .set profile "debug"
..

[profile debug]
  .set opt 0
  .set debug 1
..

[profile release]
  .set opt 2
  .set debug 0
..

[target x86_64-apple-darwin]
  .set os "macos"
  .set arch "x86_64"
..

[tool cc]
  .exec "clang"
..
EOF
</code></pre>
          </div>
        </div>
        <div class="panel terminal">
          <h3>Build</h3>
          <pre><code class="language-text">$ steel run</code></pre>
        </div>
        <p class="muted-line">Build a project:  <code>steel run</code></p>
      </section>

      <section id="analyse" class="section">
        <div class="section-title">
          <p class="kicker">Analyse</p>
          <h2>How Steel analyzes the configuration.</h2>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>Parser</h3>
            <p>
              Lexical and syntactic reading of Steel files. build of blocks
              (workspace, package, profile, target, tool).
            
            </p>
          </div>
          <div class="panel">
            <h3>Validateur</h3>
            <p>
                            Control of references, compatibility, versions, permissions and paths.
              Any inconsistency is removed before execution.
            
            </p>
          </div>
          <div class="panel">
            <h3>Resolveur</h3>
            <p>
                            Merging profiles, applying overrides, resolving dependencies
              transitives and calculation of fingerprints.
            
            </p>
          </div>
        </div>
        <div class="panel wide">
          <h3>Observation and diagnostics</h3>
          <p>
                        Steel exposes views of the resolved configuration to aid build analysis.
            The exports are text or graphs (dot), useful for diagnosing the build.
          
          </p>
        </div>
      </section>

      <section id="examples-hero" class="section examples-hero">
        <div class="section-title">
          <p class="kicker">Exemples</p>
          <h2>steelconf by language, ready to copy.</h2>
        </div>
        <div class="grid two">
          <div class="panel">
            <p>
                            Accelerate your integrations: each example shows a tool, a profile
              and a minimal target. Adapt the executables to your toolchain.
            
            </p>
            <div class="hero-actions">
              <a class="primary" href="#examples">See all examples</a>
              <a class="ghost" href="#commandes">Read all orders</a>
            </div>
          </div>
          <div class="panel hero-card">
            <p class="hero-card-title">Quick selection</p>
            <div class="chip-row">
              <span class="chip">C</span>
              <span class="chip">C++</span>
              <span class="chip">Rust</span>
              <span class="chip">Go</span>
              <span class="chip">Java</span>
              <span class="chip">C#</span>
              <span class="chip">Swift</span>
              <span class="chip">Kotlin</span>
              <span class="chip">Zig</span>
              <span class="chip">OCaml</span>
            </div>
          </div>
        </div>
      </section>


      <section id="code" class="section">
        <div class="section-title">
          <p class="kicker">Code</p>
          <h2>Reading code: internal modules and flows.</h2>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>CLI entry</h3>
            <p>
                            Binary calls  <code>steel::commands::run_cli</code>  to parse and
              execute commands.
            
            </p>
            <p class="muted-line"><code>src/bin/steel.rs</code>  ·  <code>src/commands.rs</code></p>
          </div>
          <div class="panel">
            <h3>Facade Load API</h3>
            <p>
              <code>LoadApi</code>  centralizes configuration loading, merging
              fragments and deterministic errors.
            
            </p>
            <p class="muted-line"><code>src/loadapi.rs</code></p>
          </div>
          <div class="panel">
            <h3>Phase configuration</h3>
            <p>
              <code>steel build steelconf</code>  parse, validate, resolv, then emit
              
              <code>steelconfig.mff</code>.
              No flag: everything is read from  <code>steelconf</code>.
            </p>
            <p class="muted-line"><code>src/build_muf.rs</code></p>
          </div>
        </div>
        <div class="panel wide">
          <h3>Module map (src/)</h3>
          <div class="grid two">
            <div>
              <ul>
                <li><code>parser/</code>: lexer, AST, parser MUF</li>
                <li><code>validator/</code>: coherence, references, targets</li>
                <li><code>resolver/</code>: variables, inheritance, implicit rules</li>
                <li><code>generator/</code>: emissions and exports</li>
              </ul>
            </div>
            <div>
              <ul>
                <li><code>model/</code>: workspace, profile, toolchain, rules</li>
                <li><code>runtime/</code>: OS, jobs, debug</li>
                <li><code>cli/</code>: commands and interface</li>
                <li><code>platform/</code>: VMS/remote stubs</li>
              </ul>
            </div>
          </div>
          <p class="muted-line"><code>src/MODULE_ORGANIZATION.md</code>  ·  <code>src/lib.rs</code></p>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>Parser MUF</h3>
            <p>
                            Lexer + parser transform files into stable AST. Tokens
              are defined and traversed in a deterministic manner.
            
            </p>
            <p class="muted-line"><code>src/parser/</code>  ·  <code>src/arscan.rs</code>  ·  <code>src/read.rs</code></p>
          </div>
          <div class="panel">
            <h3>Validation</h3>
            <p>
                            Checks global constraints, dependencies and specifications
              target before execution.
            
            </p>
            <p class="muted-line"><code>src/config.rs</code>  ·  <code>src/dependancies.rs</code>  · <code>src/target_file.rs</code></p>
          </div>
          <div class="panel">
            <h3>Resolution</h3>
            <p>
              Applies defaults, profile inheritance, variables and
              the implicit rules.
            
            </p>
            <p class="muted-line"><code>src/default.rs</code>  ·  <code>src/variable.rs</code>  ·  <code>src/expand.rs</code>  ·  <code>src/implicit.rs</code></p>
          </div>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Generation and export</h3>
            <p>
                            Deterministic emission of the file  <code>steelconfig.mff</code>  and
              tooling-friendly outputs.
            
            </p>
            <p class="muted-line"><code>src/output.rs</code>  ·  <code>src/generator.rs</code>  ·  <code>src/interface.rs</code></p>
          </div>
          <div class="panel">
            <h3>Execution and tools</h3>
            <p>
                            Management of jobs and tool calls, including MUF runners.
            
            </p>
            <p class="muted-line"><code>src/run_muf.rs</code>  ·  <code>src/job.rs</code>  ·  <code>src/os.rs</code></p>
          </div>
        </div>
      </section>

      <section id="deep-dive" class="section">
        <div class="section-title">
          <p class="kicker">Deep Dive</p>
          <h2>Detailed analysis of all modules.</h2>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>Lexer</h3>
            <p>
                            Deterministic tokenization: ident, int, string, punctuation. Support
              comments  <code>#</code>  and explicit EOL lines.
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef parser fill:#e7f0ff,stroke:#5a88ff,color:#1b2a44,stroke-width:1px;
  A[Source] --> B[Lexer]
  B --> C[TokenKind]
  C --> D[Span ligne/col]
  class A,B,C,D parser;</pre>
            <ul>
              <li>Line/neck position for precise diagnostics</li>
              <li>Handling string escapes (\\n, \\t, \\\")</li>
              <li>Clear error at end of string</li>
            </ul>
            <pre><code class="language-rust">pub enum TokenKind {
    Ident(String),
    Int(i64),
    Str(String),
    Dot,
}</code></pre>
            <p class="muted-line"><code>src/parser/lexer.rs</code></p>
          </div>
          <div class="panel">
            <h3>Parser</h3>
            <p>
                            Build an AST MUF with header  <code>!muf 4</code>  and blocks
              structures (<code>tool</code>,  <code>profile</code>,  <code>target</code>).
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef parser fill:#e7f0ff,stroke:#5a88ff,color:#1b2a44,stroke-width:1px;
  A[Tokens] --> B[Parser]
  B --> C[AST File]
  C --> D[Stmts + Blocks]
  class A,B,C,D parser;</pre>
            <ul>
              <li>Closed block by  <code>.end</code></li>
              <li>Statements <code>set</code> et <code>var</code></li>
              <li>Explicit error on excess tokens</li>
            </ul>
            <pre><code class="language-rust">pub fn parse_muf(src: &str;) -> Result&lt;File, ParseError&gt; {
    let mut parser = Parser::new(src);
    parser.parse_file()
}</code></pre>
            <p class="muted-line"><code>src/parser/parser.rs</code>  ·  <code>src/parser/ast.rs</code></p>
          </div>
          <div class="panel">
            <h3>Validation</h3>
            <p>
                            Stable outcome framework: severity, category, machine code,
              optional span and metadata.
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef validator fill:#e5fbf7,stroke:#3fd6c0,color:#0b3b34,stroke-width:1px;
  A[Checks] --> B[Issue]
  B --> C[Severity]
  B --> D[Category]
  B --> E[Span?]
  class A,B,C,D,E validator;</pre>
            <ul>
              <li>Fail-fast mode or complete collection</li>
              <li>Stable codes (REQUIRED, INVALID, DUPLICATE)</li>
              <li>Human formatting for CLI/CI</li>
            </ul>
            <pre><code class="language-rust">pub struct Issue {
    pub severity: Severity,
    pub category: Category,
    pub code: IssueCode,
}</code></pre>
            <p class="muted-line"><code>src/validator.rs</code></p>
          </div>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>Variables</h3>
            <p>
                            Multi-scope store (env/global/target/profile/job/local) with
              Deterministic shadowing and typed values.
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef vars fill:#fff0d9,stroke:#f59b38,color:#5a2f00,stroke-width:1px;
  A[Layers] --> B[VariableStore]
  B --> C[Shadowing]
  B --> D[Scopes]
  class A,B,C,D vars;</pre>
            <ul>
              <li>Valid credentials  <code>[A-Za-z_][A-Za-z0-9_]*</code></li>
              <li>Expansion: <code>${NAME}</code>, defaults, required</li>
              <li>Builtins: upper/lower/trim/join/path</li>
            </ul>
            <pre><code class="language-rust">pub enum VariableScope {
    Env, Global, target, profile, Job, Local,
}</code></pre>
            <p class="muted-line"><code>src/variable.rs</code></p>
          </div>
          <div class="panel">
            <h3>Expansion</h3>
            <p>
                            Simple engine, without shell:  <code>$name</code>,  <code>${name}</code>,
              and calls  <code>$(...)</code>  (env/path/lower/upper/if).
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef expand fill:#f0f7ff,stroke:#5a88ff,color:#18314b,stroke-width:1px;
  A[Input] --> B[expand]
  B --> C[Vars map]
  B --> D[Result]
  class A,B,C,D expand;</pre>
            <ul>
              <li>Strict or best-effort mode</li>
              <li>Configurable recursion limit</li>
              <li>Base dir for  <code>path:join</code></li>
            </ul>
            <pre><code class="language-rust">pub fn expand(input: &str;, vars: &Vars;, opts: &ExpandOptions;)
  -> Result&lt;String, ExpandError&gt;</code></pre>
            <p class="muted-line"><code>src/expand.rs</code></p>
          </div>
          <div class="panel">
            <h3>Implicit</h3>
            <p>
                            Deterministic injection of implicit variables, tools and rules
              with explicit trace.
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef implicit fill:#eaf8ef,stroke:#60c26a,color:#164020,stroke-width:1px;
  A[workspace] --> B[apply_implicit]
  B --> C[Vars]
  B --> D[Tools]
  B --> E[Rules]
  class A,B,C,D,E implicit;</pre>
            <ul>
              <li>Regles <code>all</code> et <code>clean</code> auto</li>
              <li>Vars workspace.root and build.dir</li>
              <li>Classification of rules</li>
            </ul>
            <pre><code class="language-rust">pub fn apply_implicit(ws: &mut; workspace, cfg: &ImplicitConfig;)
  -> Result&lt;ImplicitTrace, ImplicitError&gt;</code></pre>
            <p class="muted-line"><code>src/implicit.rs</code></p>
          </div>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>Defaults</h3>
            <p>
                            Default values policy: profile/target/dirs/toolchain,
              derived from env when available.
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef defaults fill:#fff6e9,stroke:#f59b38,color:#5a2f00,stroke-width:1px;
  A[Policy] --> B[apply_defaults]
  B --> C[Options]
  B --> D[ResolvedConfig]
  class A,B,C,D defaults;</pre>
            <ul>
              <li>Remplit <code>steel.root</code>,  <code>steel.profile</code></li>
              <li>Best-effort host triple</li>
              <li>toolchain vars sync</li>
            </ul>
            <pre><code class="language-rust">pub fn apply_defaults_to_resolved(
  cfg: &mut; ResolvedConfig,
  policy: &DefaultPolicy;
)</code></pre>
            <p class="muted-line"><code>src/default.rs</code></p>
          </div>
          <div class="panel">
            <h3>Generator</h3>
            <p>
              Deterministic emission: files, DOT graph, response files, stamp
              for change detection.
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef generator fill:#e8f1ff,stroke:#5a88ff,color:#1b2a44,stroke-width:1px;
  A[workspace] --> B[Generator]
  B --> C[Files]
  B --> D[Dot graph]
  class A,B,C,D generator;</pre>
            <ul>
              <li>BTreeMap for stable order</li>
              <li>Internal mini JSON serializer</li>
              <li>Refuse overwrite if configure</li>
            </ul>
            <pre><code class="language-rust">pub fn gen_dot(ws: &workspace;) -> String {
    let mut out = String::new();
    out.push_str(\"digraph steel {\\n\");
    out
}</code></pre>
            <p class="muted-line"><code>src/generator.rs</code></p>
          </div>
          <div class="panel">
            <h3>Output</h3>
            <p>
                            Log layer: levels, colors, optional timestamps and sinks
              captureable for testing.
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef output fill:#eef5f2,stroke:#3fd6c0,color:#0b3b34,stroke-width:1px;
  A[Event] --> B[Output]
  B --> C[Stdout]
  B --> D[Stderr]
  class A,B,C,D output;</pre>
            <ul>
              <li>Stdout/stderr + capture</li>
              <li>Event structures with metadata</li>
              <li>Line-buffered mode</li>
            </ul>
            <pre><code class="language-rust">pub enum Level {
    Error,
    Warn,
    Info,
    Debug,
}</code></pre>
            <p class="muted-line"><code>src/output.rs</code></p>
          </div>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>Interface</h3>
            <p>
                            Stable traits for loader, output, host IO, jobs and remote.
              Facilitates testing and sandboxing.
            
            </p>
            <pre class="mermaid">flowchart TD
  classDef iface fill:#e8fff9,stroke:#3fd6c0,color:#0b3b34,stroke-width:1px;
  A[IHost] --> B[FS/Env/Proc]
  C[IOutput] --> D[Logs]
  class A,B,C,D iface;</pre>
            <ul>
              <li><code>IHost</code>  for fs/env/process</li>
              <li><code>IOutput</code>  for logs</li>
              <li>IDs <code>RuleId</code>/<code>JobId</code></li>
            </ul>
            <pre><code class="language-rust">pub trait IHost: Send + Sync {
    fn read(&self;, path: &Path;) -> Result&lt;Vec&lt;u8&gt;, HostError&gt;;
}</code></pre>
            <p class="muted-line"><code>src/interface.rs</code></p>
          </div>
          <div class="panel">
            <h3>Build steelconf</h3>
            <p>
                            pipeline configuration: discovery, resolution, toolchain fingerprint,
              emission of  <code>steelconfig.mff</code>.
            </p>
            <pre class="mermaid">flowchart TD
  classDef build fill:#fff0d9,stroke:#f59b38,color:#5a2f00,stroke-width:1px;
  A[steelconf] --> B[build steelconf]
  B --> C[ResolvedConfig]
  C --> D[steelconfig.mff]
  class A,B,C,D build;</pre>
            <ul>
              <li>strict/offline/emit options</li>
              <li>Fingerprint toolchain best-effort</li>
              <li>Deterministic output</li>
            </ul>
            <pre><code class="language-rust">pub const DEFAULT_EMIT_NAME: &str; = \"steelconfig.mff\";</code></pre>
            <p class="muted-line"><code>src/build_muf.rs</code></p>
          </div>
          <div class="panel">
            <h3>CLI</h3>
            <p>
                            Minimal dispatcher:  <code>build</code>,  <code>resolve</code>,  <code>check</code>,
              
              <code>print</code>,  <code>run</code>,  <code>doctor</code>,  <code>cache</code>,
              
              <code>graph</code>,  <code>fmt</code>.
            </p>
            <pre class="mermaid">flowchart TD
  classDef cli fill:#e6ecf2,stroke:#7b8b99,color:#2a3642,stroke-width:1px;
  A[argv] --> B[parse_command]
  B --> C[execute]
  class A,B,C cli;</pre>
            <ul>
              <li>Stable error codes</li>
              <li>Std-only deterministic parsing</li>
              <li>Alias resolve/check/print</li>
            </ul>
            <pre><code class="language-rust">pub fn run_cli(args: &[String]) -> i32 {
    match dispatch(args) { Ok(()) => 0, Err(_) => 1 }
}</code></pre>
            <p class="muted-line"><code>src/commands.rs</code>  ·  <code>src/bin/steel.rs</code></p>
          </div>
        </div>
      </section>

      <section id="contrats" class="section">
        <div class="section-title">
          <p class="kicker">Contrats</p>
          <h2>The key files of the model.</h2>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>steelconf</h3>
            <p>Single source of configuration. Declarative, readable, versionable.</p>
          </div>
          <div class="panel">
            <h3>steel.log</h3>
            <p>Frozen configuration, normalized and consumed by the build engine.</p>
          </div>
        </div>
        <div class="panel wide">
          <h3>steel.log example</h3>
          <pre><code class="language-text">mff 1

build
  tool "steel"
  command "build steel"
  ts_iso "2026-01-15T14:45:46.056684+00:00"
  ok false
  message "validation error: steelconf not found: /Users/vincent/Documents/Github/muffin/examples/cpython/steelconfig"
  emit "/Users/vincent/Documents/Github/muffin/examples/cpython/steelconfig.mff"
.end

errors
  item "validation error: steelconf not found: /Users/vincent/Documents/Github/muffin/examples/cpython/steelconfig"
.end

mff 1

build
  tool "steel"
  command "build steel"
  ts_iso "2026-01-15T14:48:14.277446+00:00"
  ok true
  message "build ok"
  emit "/Users/vincent/Documents/Github/muffin/examples/cpython/steelconfig.mff"
.end</code></pre>
        </div>
        <div class="panel wide">
          <h3>steelconfig.mff example</h3>
          <p class="muted-line">
            This file is the resolved, normalized view of your configuration. It is deterministic
            and can be diffed, audited, or cached across machines.
          </p>
          <ul>
            <li><strong>project</strong>: absolute root and the source <code>steelconf</code> path.</li>
            <li><strong>select</strong>: the active profile and target triple.</li>
            <li><strong>paths</strong>: build/dist/cache directories resolved from the workspace.</li>
            <li><strong>toolchain</strong>: compiler identity plus captured versions.</li>
            <li><strong>vars</strong>: expanded variables used by the build graph.</li>
            <li><strong>fingerprint</strong>: stable hash used for cache keys and change detection.</li>
          </ul>
          <pre><code class="language-text">mff 1

project
  root "/Users/vincent/Documents/Github/muffin/examples/cpython"
  steelfile "/Users/vincent/Documents/Github/muffin/examples/cpython/ultra/steelconf"
.end

select
  profile "debug"
  target "aarch64-apple-darwin"
.end

paths
  build "/Users/vincent/Documents/Github/muffin/examples/cpython/build"
  dist "/Users/vincent/Documents/Github/muffin/examples/cpython/dist"
  cache "/Users/vincent/Documents/Github/muffin/examples/cpython/.steel-cache"
.end

toolchain
  rustc "rustc"

  versions
    rustc "rustc 1.92.0 (ded5c06cf 2025-12-08) (Homebrew)"
  .end
.end

vars
  set "steel.file" "/Users/vincent/Documents/Github/muffin/examples/cpython/ultra/steelconf"
  set "steel.offline" "false"
  set "steel.profile" "debug"
  set "steel.root" "/Users/vincent/Documents/Github/muffin/examples/cpython"
  set "steel.target" "aarch64-apple-darwin"
.end

fingerprint
  value "fnv1a64:dd41448925d7d047"
.end</code></pre>
        </div>
        <div class="grid two"></div>
      </section>

      <section id="commandes" class="section">
        <div class="section-title">
          <p class="kicker">Commandes</p>
          <h2>Complete list of Steel commands.</h2>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Help and version</h3>
            <pre><code class="language-text">steel help | -h | --help
steel version | -V | --version</code></pre>
            <p class="muted-line">List commands/options; print the exact installed Steel version.</p>
            <p class="muted-line"><code>doc/manifest.md</code></p>
          </div>
          <div class="panel">
            <h3>Configuration</h3>
            <pre><code class="language-text">steel build steelconf</code></pre>
            <p class="muted-line">Read <code>steelconf</code>, validate, and emit <code>steelconfig.mff</code>.</p>
            <p class="muted-line">Everything is read from <code>steelconf</code> (no flag).</p>
            <p class="muted-line">Aliases: <code>steel resolve</code>, <code>steel check</code>, <code>steel print</code>.</p>
          </div>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Execution</h3>
            <pre><code class="language-text">steel run [--root &lt;path&gt;] [--file &lt;path&gt;] [--profile &lt;name&gt;]
          [--toolchain &lt;path&gt;] [--bake &lt;name&gt;] [--all]
          [--print] [--no-cache]
          [--log &lt;path&gt;] [--log-mode &lt;append|truncate&gt;] [-v]</code></pre>
            <p class="muted-line">Run the build graph; choose a bake; write build logs to <code>target/</code> or <code>--log</code>.</p>
          </div>
          <div class="panel">
            <h3>Diagnostics</h3>
            <pre><code class="language-text">steel doctor [--root &lt;path&gt;] [--json] [-v]</code></pre>
            <p class="muted-line">Check environment/config and report missing tools or bad paths.</p>
          </div>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>cache</h3>
            <pre><code class="language-text">steel cache status [--root &lt;path&gt;] [--json] [-v]
steel cache clear  [--root &lt;path&gt;] [--json] [-v]</code></pre>
            <p class="muted-line"><code>status</code> shows cache usage; <code>clear</code> deletes cache entries.</p>
          </div>
          <div class="panel">
            <h3>Introspection</h3>
            <pre><code class="language-text">steel print
steel graph [--text|--dot] [-v]</code></pre>
            <p class="muted-line"><code>print</code> dumps resolved config; <code>graph</code> emits a text/DOT graph.</p>
          </div>
          <div class="panel">
            <h3>Graph (stub)</h3>
            <pre><code class="language-text">steel graph [--root &lt;path&gt;] [--text|--dot] [-v]</code></pre>
            <p class="muted-line">Graph with explicit root when running outside the workspace.</p>
          </div>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Fmt (stub)</h3>
            <pre><code class="language-text">steel fmt [--file &lt;path&gt;] [--check] [-v]</code></pre>
            <p class="muted-line">Format <code>steelconf</code>; <code>--check</code> returns nonzero if formatting differs.</p>
          </div>
          <div class="panel">
            <h3>Version</h3>
            <pre><code class="language-text">steel version | -V | --version</code></pre>
            <p class="muted-line">Print current Steel version string.</p>
          </div>
        </div>
      </section>

      <section id="syntaxe-muf" class="section">
        <div class="section-title">
          <p class="kicker">Syntaxe</p>
          <h2>Header and directives !muf 4.</h2>
        </div>
        <p class="muted-line">The file is a series of blocks; each directive begins with  <code>.</code>  and the blocks close with  <code>..</code>.</p>
        <p>
          The header <code>!muf 4</code> is mandatory and locks the grammar version so Steel can parse the file
          deterministically. After the header, every block defines a scope (workspace, tool, bake, run) and
          each directive inside that block adds a specific instruction. The parser reads top to bottom and
          preserves a stable order so the same input always yields the same resolved configuration.
        </p>
        <div class="panel wide">
          <h3>Directive explanations (simple)</h3>
          <ul>
            <li><code>!muf 4</code>: syntax version.</li>
            <li><code>[workspace]</code>: root and globals.</li>
            <li><code>[profile name]</code>: profile variables.</li>
            <li><code>[tool name]</code>: tool executable.</li>
            <li><code>[bake name]</code>: build rule.</li>
            <li><code>[run tool]</code>: tool invocation.</li>
            <li><code>[export]</code>: public targets.</li>
            <li><code>.set</code>: set key/flag.</li>
            <li><code>.exec</code>: command path.</li>
            <li><code>.make</code>: input list.</li>
            <li><code>.needs</code>: dependency.</li>
            <li><code>.takes</code>: wire inputs.</li>
            <li><code>.emits</code>: output port.</li>
            <li><code>.output</code>: output path.</li>
            <li><code>.include</code>: include path.</li>
            <li><code>.define</code>: compile define.</li>
            <li><code>.libdir</code>: library path.</li>
            <li><code>.lib</code>: link lib.</li>
            <li><code>.ref</code>: export bake.</li>
            <li><code>..</code>: end block.</li>
          </ul>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Header + blocks</h3>
            <pre><code class="language-text">!muf 4

[workspace]
  .set name "demo"
  .set root "."
..

[tool cc]
  .exec "cc"
..

[bake build]
  .make c_src cglob "src/**/*.c"
  [run cc]
    .takes c_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "target/out/app"
..</code></pre>
          </div>
          <div class="panel">
            <h3>Essential Guidelines</h3>
            <ul>
              <li><code>.set</code>: workspace/profile variables or tool flags</li>
              <li><code>.make &lt;id&gt; &lt;kind&gt; &lt;pattern&gt;</code>: <code>glob</code>/<code>cglob</code>/<code>file</code></li>
              <li><code>.make &lt;id&gt; &lt;path&gt;</code>: shortcut for  <code>file</code></li>
              <li><code>.needs &lt;bake&gt;</code>: explicit dependency</li>
              <li><code>.takes &lt;port&gt; as "@args"</code>: injects the sources</li>
              <li><code>.emits &lt;port&gt; as "-o"</code>: associates an output</li>
              <li><code>.include</code>,  <code>.define</code>,  <code>.libdir</code>,  <code>.lib</code>: compilation options</li>
              <li><code>.output &lt;port&gt; &lt;path&gt;</code>: final exit from the bake</li>
            </ul>
          </div>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Blocks available</h3>
            <ul>
              <li><code>[workspace]</code>: project root + global variables</li>
              <li><code>[profile &lt;name&gt;]</code>: variables per profile (debug/release)</li>
              <li><code>[tool &lt;name&gt;]</code>: definition of an executable tool</li>
              <li><code>[bake &lt;name&gt;]</code>: build rule with inputs/outputs</li>
              <li><code>[run &lt;tool&gt;]</code>: tool invocation in a bake</li>
              <li><code>[export]</code>: list of exported bakes</li>
            </ul>
          </div>
          <div class="panel">
            <h3>Quick rules</h3>
            <ul>
              <li><code>!muf 4</code> must be the first line.</li>
              <li>Blocks always close with <code>..</code>.</li>
              <li>All paths are relative to <code>root</code>.</li>
              <li>Globs are expanded in stable order.</li>
              <li>Variables are referenced as <code>${key}</code>.</li>
            </ul>
          </div>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Interpretation details</h3>
            <ul>
              <li><code>.set &lt;flag&gt; 1|true|yes</code> adds a flag without a value.</li>
              <li><code>.set &lt;flag&gt; 0|false|no</code> disables that flag.</li>
              <li><code>.set &lt;flag&gt; &lt;val&gt;</code> writes <code>flag</code> and its value.</li>
              <li><code>glob</code>/<code>cglob</code> scan from <code>root</code> in stable order.</li>
              <li><code>.make &lt;id&gt; &lt;path&gt;</code> is the same as <code>file</code>.</li>
              <li><code>.takes</code> only accepts <code>@args</code>.</li>
              <li>All relative paths are resolved from <code>root</code>.</li>
              <li>If no input matches, the bake fails.</li>
              <li>Skip rebuild when outputs are newer than all inputs.</li>
              <li>Fingerprinting is disabled with <code>--no-cache</code> or <code>--print</code>.</li>
              <li>Cache key = profile + toolchain + variables + inputs + outputs.</li>
              <li>Default run log: <code>target/steel_run_&lt;timestamp&gt;.mff</code>.</li>
              <li>Config log: <code>steel.log</code> at workspace root.</li>
              <li>Resolved config: <code>target/steel/config.mub</code>.</li>
              <li>Execution logs go to <code>target/</code> unless <code>--log</code> is set.</li>
              <li><code>--log-mode truncate</code> recreates the file; otherwise it appends.</li>
              <li>Fingerprint files live in <code>.steel-cache/run/&lt;bake&gt;.fp</code>.</li>
              <li>Fingerprint inputs include profile, toolchain, vars, inputs, outputs.</li>
            </ul>
          </div>
          <div class="panel">
            <h3>Quick semantics</h3>
            <ul>
              <li>A <code>[bake]</code> defines inputs, a command, and outputs.</li>
              <li><code>.needs</code> declares dependencies between bakes.</li>
              <li><code>[export]</code> lists the public bakes.</li>
              <li>The active profile provides variables via <code>${key}</code>.</li>
              <li>Outputs are the base for incremental cache checks.</li>
            </ul>
          </div>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>EBNF (minimal syntax)</h3>
            <pre><code class="language-text">Block     = WS0 , BlockHead , WS0 , NL , { BlockItem } , WS0 , BlockClose , WS0 , NL ;
BlockHead = "[" , WS0 , Tag , [ WS1 , Name ] , WS0 , "]" ;
BlockClose = ".." ;
Directive = WS0 , "." , Op , { WS1 , Atom } , WS0 , NL ;
Atom = Ref | String | Number | Name ;</code></pre>
          </div>
          <div class="panel">
            <h3>Lexemes</h3>
            <ul>
              <li><code>String</code>: quotes with exhausts  <code>\n</code>,  <code>\r</code>,  <code>\t</code>,  <code>\0</code>,  <code>\xNN</code>,  <code>\uNNNN</code></li>
              <li><code>Number</code>: <code>+42</code>,  <code>-7</code>,  <code>3.14</code>,  <code>1.2e3</code></li>
              <li><code>Ref</code>: path  <code>~name/name/...</code></li>
              <li><code>Name</code>: identifier without space</li>
            </ul>
          </div>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>EBNF (extended)</h3>
            <pre><code class="language-text">File      = Header , { Block } ;
Header    = "!muf" , WS1 , Number , NL ;

Block     = WS0 , BlockHead , WS0 , NL , { BlockItem } , WS0 , BlockClose , WS0 , NL ;
BlockHead = "[" , WS0 , Tag , [ WS1 , Name ] , WS0 , "]" ;
BlockClose = ".." ;

BlockItem = Directive | Block ;
Directive = WS0 , "." , Op , { WS1 , Atom } , WS0 , NL ;
Atom      = Ref | String | Number | Name ;</code></pre>
          </div>
          <div class="panel">
            <h3>Tags + Ops</h3>
            <ul>
              <li><code>Tag</code>: workspace, profile, tool, bake, run, export</li>
              <li><code>Op</code>  (common): set, exec, make, takes, emits, output, needs</li>
              <li><code>Op</code>  (optional): include, define, libdir, lib</li>
              <li><code>Op</code>  (runner): ref (in export)</li>
            </ul>
          </div>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Signatures (summary)</h3>
            <ul>
              <li><code>.set &lt;key&gt; &lt;value&gt;</code> — set a variable or flag value (ex: <code>.set "-O2" 1</code>).</li>
              <li><code>.exec &lt;path&gt;</code> — define the tool executable (ex: <code>.exec "cc"</code>).</li>
              <li><code>.make &lt;id&gt; &lt;kind&gt; &lt;pattern&gt;</code> — declare an input set (kind: <code>glob</code>/<code>cglob</code>/<code>file</code>).</li>
              <li><code>.make &lt;id&gt; &lt;path&gt;</code> — shorthand for a single file input.</li>
              <li><code>.needs &lt;bake&gt;</code> — declare a dependency on another bake (ex: <code>.needs lib</code>).</li>
              <li><code>.takes &lt;port&gt; as "@args"</code> — pass inputs as command-line args.</li>
              <li><code>.emits &lt;port&gt; as "-o"</code> — map an output port to a flag.</li>
              <li><code>.output &lt;port&gt; &lt;path&gt;</code> — bind the final output path.</li>
            </ul>
          </div>
          <div class="panel">
            <h3>Signatures (options)</h3>
            <ul>
              <li><code>.include &lt;path&gt;</code> — add an include path (ex: <code>.include "src"</code>).</li>
              <li><code>.define &lt;K&gt; [&lt;V&gt;]</code> — set a compile-time define (ex: <code>.define "DEBUG"</code>).</li>
              <li><code>.libdir &lt;path&gt;</code> — add a library search directory (ex: <code>.libdir "/usr/lib"</code>).</li>
              <li><code>.lib &lt;name&gt;</code> — link a library by name (ex: <code>.lib "m"</code>).</li>
              <li><code>.ref &lt;bake&gt;</code> — export a bake from <code>[export]</code>.</li>
            </ul>
          </div>
        </div>
              <div class="grid two">
          <div class="panel">
            <h3>Examples (bake)</h3>
            <pre><code class="language-text">[bake app]
  .make c_src cglob "src/**/*.c"
  .needs lib
  [run cc]
    .include "src"
    .define "DEBUG"
    .takes c_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "target/out/app"
..</code></pre>
          </div>
          <div class="panel">
            <h3>Examples (flags)</h3>
            <pre><code class="language-text">[run cc]
  .set "-O2" 1
  .set "-g" 1
  .libdir "/usr/lib"
  .lib "m"
  .takes src as "@args"
  .emits exe as "-o"
..</code></pre>
          </div>
        </div>
</section>


      <section id="examples" class="section">
        <div class="section-title">
          <p class="kicker">Exemples</p>
          <h2>Top 10 compilable languages.</h2>
        </div>
        <p class="muted-line">Header syntax:  <code>!muf 4</code></p>
        <div class="grid three">
          <div class="panel">
            <h3>C</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-c"
  .set root "."
  .set target_dir "examples/c/target"
  .set profile "release"
..

[profile debug]
  .set opt 0
  .set debug 1
..

[profile release]
  .set opt 2
  .set debug 0
..

[tool cc]
  .exec "cc"
..

[bake build_debug]
  .make c_src cglob "examples/c/src/**/*.c"
  [run cc]
    .set "-O${opt}" 1
    .set "-g" "${debug}"
    .takes c_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/c/target/out/c_app_debug"
..

[bake build_release]
  .make c_src cglob "examples/c/src/**/*.c"
  [run cc]
    .set "-O${opt}" 1
    .set "-g" "${debug}"
    .takes c_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/c/target/out/c_app_release"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/c/target/out/c_app_debug</code>,  <code>examples/c/target/out/c_app_release</code></p>
          </div>
          <div class="panel">
            <h3>C++</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-cpp"
  .set root "."
  .set target_dir "examples/cpp/target"
  .set profile "release"
..

[profile debug]
  .set opt 0
  .set debug 1
..

[profile release]
  .set opt 2
  .set debug 0
..

[tool cxx]
  .exec "c++"
..

[bake build_debug]
  .make cpp_src cglob "examples/cpp/src/**/*.cpp"
  [run cxx]
    .set "-std=c++20" 1
    .set "-O${opt}" 1
    .set "-g" "${debug}"
    .takes cpp_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/cpp/target/out/cpp_app_debug"
..

[bake build_release]
  .make cpp_src cglob "examples/cpp/src/**/*.cpp"
  [run cxx]
    .set "-std=c++20" 1
    .set "-O${opt}" 1
    .set "-g" "${debug}"
    .takes cpp_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/cpp/target/out/cpp_app_release"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/cpp/target/out/cpp_app_debug</code>,  <code>examples/cpp/target/out/cpp_app_release</code></p>
          </div>
          <div class="panel">
            <h3>Rust</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-rust"
  .set root "."
  .set target_dir "examples/rust/target"
  .set profile "release"
..

[profile debug]
  .set opt 0
  .set debug 2
..

[profile release]
  .set opt 2
  .set debug 0
..

[tool rustc]
  .exec "rustc"
..

[bake build_debug]
  .make main file "examples/rust/src/main.rs"
  [run rustc]
    .set "-C" "opt-level=${opt}"
    .set "-C" "debuginfo=${debug}"
    .takes main as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/rust/target/out/rust_app_debug"
..

[bake build_release]
  .make main file "examples/rust/src/main.rs"
  [run rustc]
    .set "-C" "opt-level=${opt}"
    .set "-C" "debuginfo=${debug}"
    .takes main as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/rust/target/out/rust_app_release"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/rust/target/out/rust_app_debug</code>,  <code>examples/rust/target/out/rust_app_release</code></p>
          </div>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>Go</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-go"
  .set root "."
  .set target_dir "examples/go/target"
  .set profile "release"
..

[profile debug]
  .set opt 0
  .set debug 1
..

[profile release]
  .set opt 2
  .set debug 0
..

[tool go]
  .exec "go"
..

[bake build_debug]
  .make go_src cglob "examples/go/cmd/app/**/*.go"
  [run go]
    .set "build" 1
    .set "-gcflags" "all=-N -l"
    .set "-o" "examples/go/target/out/go_app_debug"
    .takes go_src as "@args"
  ..
  .output exe "examples/go/target/out/go_app_debug"
..

[bake build_release]
  .make go_src cglob "examples/go/cmd/app/**/*.go"
  [run go]
    .set "build" 1
    .set "-o" "examples/go/target/out/go_app_release"
    .takes go_src as "@args"
  ..
  .output exe "examples/go/target/out/go_app_release"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/go/target/out/go_app_debug</code>,  <code>examples/go/target/out/go_app_release</code></p>
          </div>
          <div class="panel">
            <h3>Java</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-java"
  .set root "."
  .set target_dir "examples/java/target"
  .set profile "debug"
..

[tool javac]
  .exec "javac"
..

[tool jar]
  .exec "jar"
..

[profile debug]
  .set opt 0
  .set debug 1
..

[profile release]
  .set opt 2
  .set debug 0
..

[bake build_debug]
  .make java_src cglob "examples/java/src/main/java/**/*.java"
  [run javac]
    .set "-g" "${debug}"
    .set "-d" "examples/java/target/classes"
    .takes java_src as "@args"
  ..
  [run jar]
    .set "-c" 1
    .set "-f" "examples/java/target/out/app_debug.jar"
    .set "-C" "examples/java/target/classes"
    .set "." 1
  ..
  .output jar "examples/java/target/out/app_debug.jar"
..

[bake build_release]
  .make java_src cglob "examples/java/src/main/java/**/*.java"
  [run javac]
    .set "-d" "examples/java/target/classes"
    .takes java_src as "@args"
  ..
  [run jar]
    .set "-c" 1
    .set "-f" "examples/java/target/out/app_release.jar"
    .set "-C" "examples/java/target/classes"
    .set "." 1
  ..
  .output jar "examples/java/target/out/app_release.jar"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/java/target/out/app_debug.jar</code>,  <code>examples/java/target/out/app_release.jar</code></p>
          </div>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>C#</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-csharp"
  .set root "."
  .set target_dir "examples/csharp/target"
  .set profile "release"
..

[tool dotnet]
  .exec "dotnet"
..

[profile debug]
  .set opt 0
..

[profile debug]
  .set opt 0
..

[profile debug]
  .set opt 0
..

[profile debug]
  .set opt 0
..

[profile debug]
  .set opt 0
..

[profile release]
  .set opt 2
..

[bake build_debug]
  .make csproj file "examples/csharp/app.csproj"
  [run dotnet]
    .set "build" 1
    .set "examples/csharp/app.csproj" 1
    .set "-c" "Debug"
    .set "-o" "examples/csharp/target/out/debug"
  ..
  .output exe "examples/csharp/target/out/debug/app.dll"
..

[bake build_release]
  .make csproj file "examples/csharp/app.csproj"
  [run dotnet]
    .set "build" 1
    .set "examples/csharp/app.csproj" 1
    .set "-c" "Release"
    .set "-o" "examples/csharp/target/out/release"
  ..
  .output exe "examples/csharp/target/out/release/app.dll"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/csharp/target/out/debug/app.dll</code>,  <code>examples/csharp/target/out/release/app.dll</code></p>
          </div>
          <div class="panel">
            <h3>Swift</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-swift"
  .set root "."
  .set target_dir "examples/swift/target"
  .set profile "release"
..

[profile debug]
  .set opt 0
..

[profile release]
  .set opt 2
..

[tool swiftc]
  .exec "swiftc"
..

[bake build_debug]
  .make swift_src cglob "examples/swift/Sources/**/*.swift"
  [run swiftc]
    .set "-g" 1
    .takes swift_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/swift/target/out/swift_app_debug"
..

[bake build_release]
  .make swift_src cglob "examples/swift/Sources/**/*.swift"
  [run swiftc]
    .set "-O" 1
    .takes swift_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/swift/target/out/swift_app_release"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/swift/target/out/swift_app_debug</code>,  <code>examples/swift/target/out/swift_app_release</code></p>
          </div>
          <div class="panel">
            <h3>Kotlin</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-kotlin"
  .set root "."
  .set target_dir "examples/kotlin/target"
  .set profile "release"
..

[profile debug]
  .set opt 0
..

[tool kotlinc]
  .exec "kotlinc"
..

[profile release]
  .set opt 2
..

[bake build_debug]
  .make kt_src cglob "examples/kotlin/src/**/*.kt"
  [run kotlinc]
    .set "-jvm-target" "17"
    .set "-include-runtime" 1
    .set "-d" "examples/kotlin/target/out/app_debug.jar"
    .takes kt_src as "@args"
  ..
  .output jar "examples/kotlin/target/out/app_debug.jar"
..

[bake build_release]
  .make kt_src cglob "examples/kotlin/src/**/*.kt"
  [run kotlinc]
    .set "-jvm-target" "17"
    .set "-include-runtime" 1
    .set "-d" "examples/kotlin/target/out/app_release.jar"
    .takes kt_src as "@args"
  ..
  .output jar "examples/kotlin/target/out/app_release.jar"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/kotlin/target/out/app_debug.jar</code>,  <code>examples/kotlin/target/out/app_release.jar</code></p>
          </div>
        </div>
        <div class="grid three">
          <div class="panel">
            <h3>Zig</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-zig"
  .set root "."
  .set target_dir "examples/zig/target"
  .set profile "release"
..

[profile debug]
  .set opt 0
..

[tool zig]
  .exec "zig"
..

[profile release]
  .set opt 2
..

[bake build_debug]
  .make zig_src cglob "examples/zig/src/**/*.zig"
  [run zig]
    .set "build-exe" 1
    .set "-O" "Debug"
    .set "-femit-bin=examples/zig/target/out/zig_app_debug" 1
    .takes zig_src as "@args"
  ..
  .output exe "examples/zig/target/out/zig_app_debug"
..

[bake build_release]
  .make zig_src cglob "examples/zig/src/**/*.zig"
  [run zig]
    .set "build-exe" 1
    .set "-O" "ReleaseSafe"
    .set "-femit-bin=examples/zig/target/out/zig_app_release" 1
    .takes zig_src as "@args"
  ..
  .output exe "examples/zig/target/out/zig_app_release"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/zig/target/out/zig_app_debug</code>,  <code>examples/zig/target/out/zig_app_release</code></p>
          </div>
          <div class="panel">
            <h3>OCaml</h3>
            <pre><code class="language-text">!muf 4
;; Exemple complet: build_debug/build_release + sorties ciblees

[workspace]
  .set name "demo-ocaml"
  .set root "."
  .set target_dir "examples/ocaml/target"
  .set profile "release"
..

[tool ocamlc]
  .exec "ocamlc"
..

[tool ocamlopt]
  .exec "ocamlopt"
..

[profile debug]
  .set opt 0
  .set debug 1
..

[profile release]
  .set opt 2
  .set debug 0
..

[bake build_debug]
  .make ml_src cglob "examples/ocaml/ultra/src/**/*.ml"
  [run ocamlc]
    .set "-g" 1
    .set "-I" "examples/ocaml/ultra/src"
    .set "-I" "+unix"
    .set "unix.cma" 1
    .takes ml_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/ocaml/target/out/ocaml_app_debug"
..

[bake build_release]
  .make ml_src cglob "examples/ocaml/ultra/src/**/*.ml"
  [run ocamlopt]
    .set "-O2" 1
    .set "-I" "examples/ocaml/ultra/src"
    .set "-I" "+unix"
    .set "unix.cmxa" 1
    .takes ml_src as "@args"
    .emits exe as "-o"
  ..
  .output exe "examples/ocaml/target/out/ocaml_app_release"
..</code></pre>
            <p class="muted-line">Expected outputs:  <code>examples/ocaml/target/out/ocaml_app_debug</code>,  <code>examples/ocaml/target/out/ocaml_app_release</code></p>
          </div>
        </div>
      </section>

      <section id="recap" class="section">
        <div class="section-title">
          <p class="kicker">Recap</p>
          <h2>A unique config, a canonical output.</h2>
        </div>
        <div class="grid two">
          <div class="panel">
            <h3>Why Steel</h3>
            <p>
                            Steel separates configuration from execution. The objective is to make
              the portable, observable and reproducible build, whatever the language
              or the machine.
            </p>
            <ul>
              <li>Declarative, explicit and stable configuration</li>
              <li>Canonical artifact for audit, CI and debug</li>
              <li>Native introspection (print/graph)</li>
            </ul>
          </div>
        </div>
      </section>
    </main>

    <footer class="footer">
      <p>Steel Wiki — declarative and deterministic model.</p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/highlight.min.js"></script>
    <script>
      document.querySelectorAll("pre code").forEach((block) => {
        const text = block.textContent || "";
        if (text.includes("!muf 4")) {
          block.classList.add("language-json");
          hljs.highlightElement(block);
        }
      });
    </script>
    <script>
      mermaid.initialize({
        startOnLoad: true,
        theme: "base",
        themeVariables: {
          background: "#f7f2ea",
          primaryColor: "#ffffff",
          primaryTextColor: "#1c2228",
          primaryBorderColor: "#d8cfc2",
          lineColor: "#f59b38",
          secondaryColor: "#f2ede5",
          tertiaryColor: "#faf7f2",
          noteBkgColor: "#fff4e5",
          noteTextColor: "#6a5a45",
          fontFamily: "IBM Plex Sans, Segoe UI, sans-serif",
        },
      });
    </script>    <script src="app.js"></script>
  </body>
</html>
